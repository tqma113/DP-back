{"blocks":[{"key":"fltl3","text":"示例\n先来通过一个简单的数据查询，看一下它的模式和结构。\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"a1oom","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":0}],"data":{"float":"","alignment":""}},{"key":"fnpqd","text":"上图中有三个主要的部分：\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ecrj3","text":"左边的客户端查询结构","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"5imf0","text":"右边的服务器返回数据","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"envba","text":"针对图中的各个部分，先做一下说明：\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"arkuq","text":"左边部分分为三级。第一级 query ：表示它是一个数据查询的请求；第二级 users ：表示它要查询的信息是所有 user 的信息；第三级 id、name、address ：表示它需要的是 user 的 id、name、address 信息。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":13,"length":5,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"8g8lt","text":"右边部分的数据结构，以左边所定义的结构一致。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"eg42r","text":"\n\n整体结构\n上面介绍了一下 GraphQL 可以做什么，接下来介绍一下，怎么做到这件事。\n在GraphQL整个数据查询操作中，主要有四个部分，除了上述提到两个部分 query和返回数据，还有两个比较重要的：Schema 和 Resolver。\nSchema\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3e66k","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":1}],"data":{"float":"","alignment":""}},{"key":"7mi3p","text":"Resolver\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"8f0fb","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":2}],"data":{"float":"","alignment":""}},{"key":"9fc8e","text":"所以，使用 GraphQL 的过程就是：\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"dv5gh","text":"根据业务场景和数据结构定义 Schema ，这将是前后端交互的数据格式。","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"g41s","text":"根据 Schema 中定义的结构，对 Schema 中定义的每个操作都对应实现一个后端逻辑函数。","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"3e1od","text":"前端依照 Schema 编写自己所需要的结构的 Query，然后向后端发送 Query，就可以做相应的操作和拿到对应的数据。","type":"ordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"1t2pi","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":3}],"data":{}},{"key":"10goa","text":"核心概念\n从上面的内容可以看出 GraphQL 的核心就是 Schema 的设计和 Resolver 的实现。接下来就说一下在 GraphQL 中如何实现他们。\nType\nGraphQL有自己的类型系统，用于定义API的模式。编写模式的语法称为模式定义语言（SDL）。\n标量类型和枚举类型\nGraphQL 自带一组默认标量类型：\n","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":4,"style":"BOLD"},{"offset":135,"length":9,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"ct3tn","text":"Int：有符号 32 位整数。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":3,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"dtjl4","text":"Float：有符号双精度浮点值。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":5,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"5cl6k","text":"String：UTF‐8 字符序列。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":6,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"e1bd2","text":"Boolean：true 或者 false。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":7,"style":"CODE"},{"offset":8,"length":4,"style":"CODE"},{"offset":16,"length":5,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"9tqer","text":"ID：ID 标量类型表示一个唯一标识符，通常用以重新获取对象或者作为缓存中的键。ID 类型使用和 String 一样的方式序列化；然而将其定义为 ID 意味着并不需要人类可读型。","type":"unordered-list-item","depth":0,"inlineStyleRanges":[{"offset":0,"length":2,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"b8n6t","text":"type hero {   id: ID   name: String   appearsIn: Boolean }\n也可以自己定义枚举类型\nenum Episode { NEWHOPE EMPIRE JEDI }\n也可以自定义类型\nscalar Date\n\n\n接口和对象类型\n一个 GraphQL schema 中的最基本的组件是对象类型，它就表示你可以从服务上获取到什么类型的对象，以及这个对象有什么字段。\ntype hero {   id: ID   name: String   appearsIn: Boolean }\n跟许多类型系统一样，GraphQL 支持接口。一个接口是一个抽象类型，它包含某些字段，而对象类型必须包含这些字段，才能算实现了这个接口。\ninterface Character { id: ID name: String friends: [Character] appearsIn: Boolean } \n然后和对象类型一起用。\ntype Human implements Character { id: ID name: String friends: [Character] appearsIn: [Episode] starships: [Starship] totalCredits: Int } \n列表\n这个实际上上面已经用到了。\nmyField: [String]\n非空\n在字段（Field）后面加一个 ! 就表示他是必需（Non-Null）的。\ntype Query { user(id: ID!): User! }\nSchema\n这一部分也是是 GraphQL 最核心的概念了。\n关系型数据\n通过之前其他概念的介绍，应该可以感觉到其中一些东西了。依赖类型系统我们可以定义出完整系统的 Schema。\n","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":71,"length":4,"style":"COLOR-F1403C"},{"offset":76,"length":7,"style":"COLOR-F1403C"},{"offset":86,"length":7,"style":"COLOR-F1403C"},{"offset":94,"length":6,"style":"COLOR-F1403C"},{"offset":101,"length":4,"style":"COLOR-F1403C"},{"offset":646,"length":4,"style":"COLOR-F1403C"},{"offset":651,"length":5,"style":"COLOR-F1403C"},{"offset":659,"length":8,"style":"COLOR-F1403C"},{"offset":668,"length":5,"style":"COLOR-F1403C"},{"offset":674,"length":5,"style":"COLOR-F1403C"},{"offset":131,"length":7,"style":"BOLD"},{"offset":290,"length":2,"style":"BOLD"},{"offset":570,"length":2,"style":"BOLD"},{"offset":605,"length":2,"style":"BOLD"},{"offset":714,"length":5,"style":"BOLD"},{"offset":369,"length":6,"style":"COLOR-0084FF"},{"offset":408,"length":7,"style":"COLOR-0084FF"},{"offset":478,"length":6,"style":"COLOR-0084FF"}],"entityRanges":[],"data":{}},{"key":"8g6dv","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":4}],"data":{"float":"","alignment":""}},{"key":"5e0nc","text":"\n图片来自 https://graphqleditor.com/GraphQL 的设计人员最开始的时候选定的方向应该就是将这样的模式，是不是很像类图但有种构建数据库的感觉。\nQuery\n在 GraphQL 中的操作类型有三种：query、mutation、subscription。\n","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":87,"length":5,"style":"BOLD"}],"entityRanges":[],"data":{}},{"key":"4ufmv","text":"query（查询）：当获取数据时，应当选取Query类型","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"89hf9","text":"{ allPersons(last: 2) { name } } \n","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":19,"length":1,"style":"COLOR-0084FF"}],"entityRanges":[],"data":{}},{"key":"eku3a","text":"mutation（更改）：当尝试修改数据时，应当使用mutation类型","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"b334h","text":"mutation { createPerson(name: \"Bob\", age: 36) { name age } } \n","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":30,"length":5,"style":"COLOR-F1403C"},{"offset":42,"length":2,"style":"COLOR-0084FF"}],"entityRanges":[],"data":{}},{"key":"2mnqi","text":"subscription（订阅）：当希望数据更改时，可以进行消息推送，使用subscription类型","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9m4aa","text":"subscription { newPerson { name age } } \nResolver\n如果我们仅仅在Schema中声明了若干Query，那么我们只进行了一半的工作，因为我们并没有提供相关Query所返回数据的逻辑。为了能够使GraphQL正常工作，我们还需要再了解一个核心概念——Resolver（解析函数）。\n// schema type Query { user: User } type User { id: ID name: String } // resolver const resolver = { user: () => ({ id: \"id-1\", name: \"user-1\" }) } \n这里可以看到 Resolver 的函数和 Schema 的 Field 是一一对应的，Schema 中的每个字段都可以对应一个 Resolver 函数或者一个简单的值，而解析的最终结果，就是要得到与Schema定义的相似的数据结构。\n而且架构内部自动完成了根据 query 语句中的字段过滤数据，来看下例子：\n","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":41,"length":8,"style":"BOLD"},{"offset":147,"length":14,"style":"CODE"},{"offset":163,"length":10,"style":"ITALIC"},{"offset":233,"length":12,"style":"ITALIC"},{"offset":163,"length":10,"style":"COLOR-999999"},{"offset":233,"length":12,"style":"COLOR-999999"},{"offset":224,"length":6,"style":"COLOR-0084FF"},{"offset":283,"length":6,"style":"COLOR-F1403C"},{"offset":297,"length":8,"style":"COLOR-F1403C"}],"entityRanges":[],"data":{}},{"key":"7rt4h","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":5}],"data":{"float":"","alignment":""}},{"key":"8q8ai","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":6}],"data":{"float":"","alignment":""}},{"key":"5uo1r","text":"\n\n可以看到在第二张图片中，query 语句中删掉了 address 字段，返回数据中就不再包含address 字段了，而 resolver 函数不需要做任何改动。\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"f6lqi","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":7}],"data":{}},{"key":"ep69","text":"GraphQL VS RESTful\nREST即Representational State Transfer的缩写，可译为\"表现层状态转化”。REST最大的几个特点为：资源、统一接口、URI和无状态。\nGraphQL：Graph Query Language（图查询语言）。\nSchema VS Route\n资源的主导者不同\n这里涉及到一个资源的概念。\nRESTful的核心思想就是资源，每个资源都能用一个URL来表示，你能通过一个GET请求访问该URL从而获取该资源，而URL是后端去设置，前端来使用的，所以RESTful中资源的主导者是后端。\n而在 GraphQL 中资源的定义和获取方式是Schema。Schema 是前后端约定整体结构，前端使用时再通过部分Schema来规定返回的数据结构，这时资源的主导偏向了前端。\n资源的静态和动态\nRESTful 使用路由将URL和资源进行绑定，每个接口都只能做固定的事。\nSchema 的灵活性允许在后端不做任何改动的情况下，前端做很多不同的事情。\nRESTful的诸多痛点\n过量（Overfetching）和不足（Underfetching）\n过量：客户端下载的信息量超过了应用程序中实际需要的信息量。\n我们常常遇到数据（功能）相似，接口复用的情况，但这种情况会导致在体量过大时大量的带宽浪费。\n// 请求路径 /userInfo?userId=2 \n\n\n// 返回数据 { \"data\": { \"user\": { \"id\": \"2\", \"name\": \"b\", \"address\": \"bb\", \"bankCards\": [ { \"id\": \"1\", \"card_number\": \"12312314123123\", \"bank_name\": \"BBC\" } ] } } }\n有些场景用不到 bankCards 这个字段，这些数据传输的带宽就浪费了。\n如果将他们分拆成两个接口，那就回遇到另一个不足和n + 1问题。\n欠缺通常意味着特定端点不能提供足够的所需信息。客户端将不得不提出额外的请求以获取所需的一切。\n就意味着一个节点的资源需要 n + 1 次请求去获取。在上述例子中就是 2 次。每次请求的附加资源浪费也是巨大的。而使用GraphQL就不存在这个问题，需要那些数据就返回哪些数据。\n","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":18,"style":"BOLD"},{"offset":155,"length":8,"style":"BOLD"},{"offset":364,"length":8,"style":"BOLD"},{"offset":463,"length":34,"style":"BOLD"},{"offset":574,"length":8,"style":"ITALIC"},{"offset":574,"length":8,"style":"COLOR-999999"},{"offset":599,"length":1,"style":"COLOR-0084FF"},{"offset":604,"length":2,"style":"COLOR-F1403C"},{"offset":607,"length":4,"style":"COLOR-F1403C"},{"offset":640,"length":3,"style":"COLOR-F1403C"},{"offset":653,"length":3,"style":"COLOR-F1403C"},{"offset":669,"length":4,"style":"COLOR-F1403C"},{"offset":698,"length":3,"style":"COLOR-F1403C"},{"offset":718,"length":16,"style":"COLOR-F1403C"},{"offset":749,"length":5,"style":"COLOR-F1403C"},{"offset":614,"length":6,"style":"COLOR-175199"},{"offset":624,"length":6,"style":"COLOR-175199"},{"offset":634,"length":4,"style":"COLOR-175199"},{"offset":645,"length":6,"style":"COLOR-175199"},{"offset":658,"length":9,"style":"COLOR-175199"},{"offset":675,"length":11,"style":"COLOR-175199"},{"offset":692,"length":4,"style":"COLOR-175199"},{"offset":703,"length":13,"style":"COLOR-175199"},{"offset":736,"length":11,"style":"COLOR-175199"}],"entityRanges":[],"data":{}},{"key":"3niav","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":8}],"data":{"float":"","alignment":""}},{"key":"dt3sf","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":9}],"data":{"float":"","alignment":""}},{"key":"7bpip","text":"前端的快速产品迭代\n产品的快速迭代都伴随着对UI的更改，使用RESTful，每次修改UI还需要调整后端以满足新的数据需求。这会降低生产力并显着降低将用户反馈纳入产品的能力，每次改动都需要前后端同时修改，而多终端的情况导致的后果更加严重。\n使用GraphQL，这个问题就解决了。由于GraphQL的灵活性，客户端的更改可以在服务器上进行任何额外的工作。由于客户可以指定其确切的数据要求，因此当前端的设计和数据需求发生变化时，后端工程师无需进行调整。\n架构和类型系统的好处\nGraphQL使用强类型系统来定义API的功能。所有这一切都在API中暴露的类型都在写下来的模式使用GraphQL模式定义语言（SDL）。此模式用作客户端和服务器之间的契约，以定义客户端如何访问数据。\n一旦定义了模式，处理前端和后端的团队就可以在没有进一步通信的情况下完成工作，因为他们都知道通过网络发送的数据的确定结构。\n对比图\n","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":9,"style":"BOLD"},{"offset":224,"length":10,"style":"BOLD"},{"offset":397,"length":3,"style":"BOLD"},{"offset":280,"length":3,"style":"ITALIC"}],"entityRanges":[],"data":{}},{"key":"5a2p7","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":10}],"data":{"float":"","alignment":""}},{"key":"620fq","text":"图片来自www.howtographql.com","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"2od8g","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":11}],"data":{"float":"","alignment":""}},{"key":"b26t5","text":"图片来自www.howtographql.com框架\n服务器端库\nGraphQL.js\nGraphQL 规范的参考实现，设计用于在 Node.js 环境中运行。\nexpress-graphql\n基于 Express webserver 服务器的一个 GraphQL API 服务端参考实现，你可以用它结合常规 Express webserver 来运行 GraphQL，也可以作为独立 GraphQL 服务器。\nApollo Server\n来自于 Apollo 的一套 GraphQL server 包，可用于多种 NodeJS HTTP 框架（Express，Connect，Hapi，Koa 等）。\n各种语言实现的服务端框架。\n客户端库\nRelay\nRelay是一个JavaScript框架，用于构建由GraphQL提供支持的数据驱动的React应用程序，从一开始就设计为易于使用，可扩展，最重要的是高性能。\nApollo Client\n一个强大的 JavaScript GraphQL 客户端，设计用于与 React、React Native、Angular 2 或者原生 JavaScript 一同工作。\ngraphql-request\n一个简单的弹性的 JavaScript GraphQL 客户端，可以运行于所有的 JavaScript 环境（浏览器，Node.js 和 React Native）—— 基本上是fetch的轻度封装。\nApollo Client VS Relay\n","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":24,"length":2,"style":"BOLD"},{"offset":33,"length":10,"style":"BOLD"},{"offset":81,"length":15,"style":"BOLD"},{"offset":206,"length":13,"style":"BOLD"},{"offset":321,"length":5,"style":"BOLD"},{"offset":407,"length":13,"style":"BOLD"},{"offset":507,"length":15,"style":"BOLD"},{"offset":624,"length":22,"style":"BOLD"},{"offset":507,"length":15,"style":"UNDERLINE"},{"offset":612,"length":5,"style":"CODE"}],"entityRanges":[{"offset":507,"length":15,"key":12}],"data":{}},{"key":"5o2hd","text":"a","type":"atomic","depth":0,"inlineStyleRanges":[],"entityRanges":[{"offset":0,"length":1,"key":13}],"data":{"float":"","alignment":""}},{"key":"6us5t","text":"一些业务场景的解决方案\nGraphQL和RESTful的不同，导致一些RESTful可以完成的功能，使用GraphQL时你可能不能快速的找到很好的方案，所以我挑选了一些功能，对他们在GraphQL的基础上为使用者提供一些方案。\n服务器端渲染\n我研究了Redux和Apollo的服务器端的实现方式，发现他们大同小异。\nReact\n// Create a new React element const App = <Component />; // Render element to string const html = renderToString(App); res.send(html) \nRedux\n// Server // Create a new Redux store instance const store = createStore(counterApp) // Grab the initial state from our Redux store const preloadedState = store.getState() window.__PRELOADED_STATE__ = ${JSON.stringify(preloadedState).replace( /</g, '\\ ' )} res.send(renderFullPage(html, preloadedState)) function renderFullPage(html, preloadedState) { return `     <!doctype html>     <html>       <head>         <title>Redux Universal Example</title>       </head>       <body>         <div id=\"root\">${html}</div>         <script>           // WARNING: See the following for security issues around embedding JSON in HTML:           // http://redux.js.org/recipes/ServerRendering.html#security-considerations           window.__PRELOADED_STATE__ = ${JSON.stringify(preloadedState).replace( /</g, '\\ ' )}         </script>         <script src=\"/static/bundle.js\"></script>       </body>     </html>     ` } \n\n\n// Client // Grab the state from a global variable injected into the server-generated HTML const preloadedState = window.__PRELOADED_STATE__ // Allow the passed state to be garbage-collected delete window.__PRELOADED_STATE__ // Create Redux store with initial state const store = createStore(counterApp, preloadedState) hydrate( <Provider store={store}> <App /> </Provider>, document.getElementById('root') ) \nApollo\n// Server const client = new ApolloClient(....); const content = ReactDOM.renderToString(App); const initialState = client.extract(); const html = <Html content={content} state={initialState} />; function Html({ content, state }) { return ( <html> <body> <div id=\"root\" dangerouslySetInnerHTML={{ __html: content }} /> <script dangerouslySetInnerHTML={{ __html: `window.__APOLLO_STATE__=${JSON.stringify(state).replace(/</g, '\\ ')};`, }} /> </body> </html> ); } res.send(`<!doctype html>\\n${ReactDOM.renderToStaticMarkup(html)}`); ","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":0,"length":11,"style":"BOLD"},{"offset":158,"length":5,"style":"BOLD"},{"offset":299,"length":5,"style":"BOLD"},{"offset":1625,"length":6,"style":"BOLD"},{"offset":164,"length":30,"style":"ITALIC"},{"offset":221,"length":28,"style":"ITALIC"},{"offset":305,"length":47,"style":"ITALIC"},{"offset":390,"length":47,"style":"ITALIC"},{"offset":1215,"length":91,"style":"ITALIC"},{"offset":1356,"length":50,"style":"ITALIC"},{"offset":1440,"length":41,"style":"ITALIC"},{"offset":1632,"length":10,"style":"ITALIC"},{"offset":164,"length":30,"style":"COLOR-999999"},{"offset":221,"length":28,"style":"COLOR-999999"},{"offset":305,"length":47,"style":"COLOR-999999"},{"offset":390,"length":47,"style":"COLOR-999999"},{"offset":1215,"length":91,"style":"COLOR-999999"},{"offset":1356,"length":50,"style":"COLOR-999999"},{"offset":1440,"length":41,"style":"COLOR-999999"},{"offset":1632,"length":10,"style":"COLOR-999999"},{"offset":477,"length":6,"style":"COLOR-0084FF"},{"offset":1329,"length":6,"style":"COLOR-0084FF"},{"offset":1413,"length":6,"style":"COLOR-0084FF"},{"offset":1590,"length":8,"style":"COLOR-0084FF"},{"offset":548,"length":4,"style":"COLOR-C2A469"},{"offset":1096,"length":4,"style":"COLOR-C2A469"},{"offset":2051,"length":4,"style":"COLOR-C2A469"},{"offset":554,"length":4,"style":"COLOR-F1403C"},{"offset":664,"length":145,"style":"COLOR-F1403C"},{"offset":813,"length":243,"style":"COLOR-F1403C"},{"offset":1102,"length":4,"style":"COLOR-F1403C"},{"offset":1108,"length":1,"style":"COLOR-F1403C"},{"offset":1110,"length":99,"style":"COLOR-F1403C"},{"offset":1578,"length":11,"style":"COLOR-F1403C"},{"offset":1614,"length":6,"style":"COLOR-F1403C"},{"offset":1895,"length":6,"style":"COLOR-F1403C"},{"offset":1994,"length":27,"style":"COLOR-F1403C"},{"offset":2057,"length":4,"style":"COLOR-F1403C"},{"offset":2062,"length":3,"style":"COLOR-F1403C"},{"offset":2074,"length":6,"style":"COLOR-F1403C"},{"offset":2082,"length":6,"style":"COLOR-F1403C"},{"offset":2103,"length":20,"style":"COLOR-F1403C"},{"offset":2158,"length":2,"style":"COLOR-F1403C"}],"entityRanges":[],"data":{}},{"key":"f5hnr","text":"\n认证\nApollo\n集成在框架内，有开关和暴露出来的API。Authentication | Apollo Client\nRelay\n有插件实现该功能：react-relay-network-modern\n分页\n分页这个功能中Apollo和Relay采用了相似的方式：使用variables + connection。\n但这个方式也有两种不同的分页方案，但也比较传统：Offset、Cursor。\nOffset：表示出当前所在位置和每次获取的数据量的间隔\n// Offset query Feed($type: FeedType!, $offset: Int, $limit: Int) { currentUser { login } feed(type: $type, offset: $offset, limit: $limit) { id # ... } } \nCursor：表示出下次获取数据时的开始位置\n// Cursor query MoreComments($cursor: String) { moreComments(cursor: $cursor) { cursor comments { author text } } } \n数据缓存\n问题：\n","type":"code-block","depth":0,"inlineStyleRanges":[{"offset":4,"length":6,"style":"BOLD"},{"offset":62,"length":5,"style":"BOLD"},{"offset":229,"length":10,"style":"ITALIC"},{"offset":408,"length":10,"style":"ITALIC"},{"offset":229,"length":10,"style":"COLOR-999999"},{"offset":408,"length":10,"style":"COLOR-999999"},{"offset":374,"length":1,"style":"COLOR-F1403C"},{"offset":446,"length":6,"style":"COLOR-0084FF"}],"entityRanges":[{"offset":31,"length":30,"key":14},{"offset":77,"length":26,"key":15}],"data":{}},{"key":"8g89h","text":"HTTP 缓存通常不支持 POST 请求或长缓存键","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"daoca","text":"越复杂的请求可能意味着更少的缓存命中","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"88hi1","text":"GraphQL 的传输是独立的，因此 HTTP 缓存并不总是可行","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"cha4f","text":"GraphQL 解决方向：\n","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"55j7g","text":"访问后端时，在模式和解析器旁声明缓存控制信息的可能性","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9dl6i","text":"基于模式的自动化细粒度缓存控制，而不必单独考虑每个请求","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"130j1","text":"DataLoader （Server 端 Resolver 缓存）\nDataloader 是 facebook 推出的一款通用工具，可为传统应用层与持久层之间提供一款缓存和批处理的操作。JS、Java、Ruby、Go等主流语言都有开源三方库支持。尤其在 GraphQL 兴起后，DataLoader被广泛地应用于解决N+1查询问题。\n它主要做了两件事情：\n","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":33,"style":"BOLD"},{"offset":83,"length":2,"style":"ITALIC"},{"offset":86,"length":3,"style":"ITALIC"}],"entityRanges":[{"offset":158,"length":7,"key":16}],"data":{}},{"key":"f2qrq","text":"批处理（很像React的setState）","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"9d9jc","text":"内存级缓存","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"bk8ul","text":"全局唯一id（Client 端 Query 缓存）\n分割数据到单个对象将其保存到存储（内存缓存），对于每个对象创建一个唯一的标识符，并且存储那些对象在扁平的数据结构中之前归一化数据。\n\n__id + __typename / API id（Client 端 Query 缓存）\n虽然全局唯一 ID 在过去已经被证明是一种强大的模式，但它们并不是唯一可以使用的模式，也不适用于每种情况。客户端需要的真正关键功能是为其缓存导出全局唯一标识符的能力。服务器可以导出此 ID 以简化客户端，而客户端同样也可以导出标识符。通常，将对象的类型（通过 __typename+ __id 查询）与某些类型唯一标识符相结合就很简单。\n另外，如果使用 GraphQL API 替换现有的 API，那么如果 GraphQL 中的其他所有字段都相同，只更换了全局唯一的 id，这可能会令人困惑。这可能是为什么不选用 id 作为全局唯一字段的另一个原因，使用__id + API id。","type":"unstyled","depth":0,"inlineStyleRanges":[{"offset":0,"length":25,"style":"BOLD"},{"offset":93,"length":6,"style":"BOLD"},{"offset":100,"length":38,"style":"BOLD"},{"offset":363,"length":1,"style":"BOLD"},{"offset":95,"length":4,"style":"ITALIC"},{"offset":269,"length":10,"style":"CODE"},{"offset":373,"length":2,"style":"CODE"},{"offset":396,"length":2,"style":"CODE"}],"entityRanges":[],"data":{}},{"key":"cl2e0","text":"\n文件上传\n这个的解决方案有两种：","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"49e1c","text":"将上传的接口独立出来使用传统的文件上传方式（场景特殊，单个操作对GraphQL服务器压力较大）","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"ht9t","text":"使用Variables上传文件的 base64","type":"unordered-list-item","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}},{"key":"drje","text":"数据库连接","type":"unstyled","depth":0,"inlineStyleRanges":[],"entityRanges":[],"data":{}}],"entityMap":{"0":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"meta":{},"url":"https://pic4.zhimg.com/80/v2-3153cddfc5a25de2d19a10357e23ce27_hd.jpg"}},"1":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"meta":{},"url":"https://pic4.zhimg.com/80/v2-a44be6efc8712b54e71e7cab0854ac17_hd.jpg"}},"2":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"meta":{},"url":"https://pic2.zhimg.com/80/v2-60d37ffdaa4e6761e77144152a8be935_hd.jpg"}},"3":{"type":"HR","mutability":"IMMUTABLE","data":{}},"4":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"meta":{},"url":"https://pic4.zhimg.com/v2-27e943ff899b0e96154255ad56f310f3_b.jpg"}},"5":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"meta":{},"url":"https://pic2.zhimg.com/80/v2-212c7dc2f0adf9ed8524bbda95808839_hd.jpg"}},"6":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"meta":{},"url":"https://pic2.zhimg.com/80/v2-8ff4d9bb4eee97aa7a9554489d5a398d_hd.jpg"}},"7":{"type":"HR","mutability":"IMMUTABLE","data":{}},"8":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"meta":{},"url":"https://pic2.zhimg.com/80/v2-c23dadd93fa857136a7ffebeb3c34365_hd.jpg"}},"9":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"meta":{},"url":"https://pic1.zhimg.com/80/v2-b6e8732380f14796613aab8a452b00dc_hd.jpg"}},"10":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"meta":{},"url":"https://pic2.zhimg.com/80/v2-9b29c679f9e52c4cec98db74b7df5361_hd.jpg"}},"11":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"meta":{},"url":"https://pic4.zhimg.com/80/v2-aaaeaf20a3758553ccf0238e12454f4f_hd.jpg"}},"12":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://link.zhihu.com/?target=https%3A//github.com/graphcool/graphql-request","target":"_blank"}},"13":{"type":"IMAGE","mutability":"IMMUTABLE","data":{"meta":{},"url":"https://pic1.zhimg.com/80/v2-3804cd99e90444f61f6d06892f7a2424_hd.jpg"}},"14":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://link.zhihu.com/?target=https%3A//www.apollographql.com/docs/react/recipes/authentication.html","target":"_blank"}},"15":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://link.zhihu.com/?target=https%3A//github.com/relay-tools/react-relay-network-modern","target":"_blank"}},"16":{"type":"LINK","mutability":"MUTABLE","data":{"href":"https://link.zhihu.com/?target=https%3A//stackoverflow.com/questions/97197/what-is-the-n1-select-query-issue","target":"_blank"}}}}